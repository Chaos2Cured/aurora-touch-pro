<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Aurora Touch Pro â€” Fractal Glow</title>
  <style>
    html, body, canvas {
      margin: 0;
      overflow: hidden;
      background: #000;
      width: 100%;
      height: 100%;
    }
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font: 12px monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 6px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hud">FPS: --</div>

  <script type="x-shader/x-fragment" id="frag">
    precision highp float;
    uniform vec2 u_res, u_center, u_touch;
    uniform float u_zoom, u_time;

    float mandelbrot(vec2 c){
      vec2 z = vec2(0.0);
      float i;
      for(i = 0.0; i < 100.0; i++){
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z) > 4.0) break;
      }
      return i;
    }

    vec3 palette(float t){
      return 0.5 + 0.5 * cos(6.2831 * (t + vec3(0.0, 0.33, 0.67)));
    }

    void main(){
      vec2 uv = (gl_FragCoord.xy - u_res * 0.5) / u_res.y / u_zoom + u_center;
      float m = mandelbrot(uv) / 100.0;
      vec3 color = palette(m + u_time * 0.05);

      float glow = exp(-length(gl_FragCoord.xy - u_touch) * 0.02);
      color += vec3(0.9, 0.8, 0.6) * glow;

      gl_FragColor = vec4(color, 1.0);
    }
  </script>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const hud = document.getElementById('hud');

    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.onresize = resize;
    resize();

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    const vShader = compileShader(gl.VERTEX_SHADER, 'attribute vec4 a; void main() { gl_Position = a; }');
    const fShader = compileShader(gl.FRAGMENT_SHADER, document.getElementById('frag').textContent);

    const prog = gl.createProgram();
    gl.attachShader(prog, vShader);
    gl.attachShader(prog, fShader);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
    }
    gl.useProgram(prog);

    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const pos = gl.getAttribLocation(prog, 'a');
    gl.enableVertexAttribArray(pos);
    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

    const u_res = gl.getUniformLocation(prog, 'u_res'),
          u_center = gl.getUniformLocation(prog, 'u_center'),
          u_zoom = gl.getUniformLocation(prog, 'u_zoom'),
          u_time = gl.getUniformLocation(prog, 'u_time'),
          u_touch = gl.getUniformLocation(prog, 'u_touch');

    let center = [-0.75, 0.0], zoom = 0.9;
    let touch = [canvas.width / 2, canvas.height / 2];

    canvas.onpointermove = e => {
      const rect = canvas.getBoundingClientRect();
      touch = [
        (e.clientX - rect.left) * devicePixelRatio,
        canvas.height - (e.clientY - rect.top) * devicePixelRatio
      ];
    };

    let lastTime = performance.now();
    function loop(time) {
      gl.uniform2f(u_res, canvas.width, canvas.height);
      gl.uniform2f(u_center, center[0], center[1]);
      gl.uniform1f(u_zoom, zoom);
      gl.uniform1f(u_time, time * 0.001);
      gl.uniform2f(u_touch, touch[0], touch[1]);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      hud.textContent = `FPS: ${(1000 / (time - lastTime)).toFixed(1)}`;
      lastTime = time;
      requestAnimationFrame(loop);
    }

    loop(lastTime);
  </script>
</body>
</html>
