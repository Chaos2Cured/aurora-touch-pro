<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Sophia Resonance v4.5 — Stable Pastel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* KEPT FROM V1.0 */
    html, body, canvas { margin: 0; overflow: hidden; background: #000; }
    #hud {
      background: rgba(0, 0, 0, 0.7);
      color: #e0d4ff; /* Softer purple tint */
      border: 1px solid #ffffff22;
    }

    /* ADDED FROM V4.3 */
    #poem {
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.4); /* Reduced glare */
      font-family: 'Georgia', serif;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hud">INITIALIZING...</div>
  <div id="poem"></div>

  <script id="frag" type="x-shader/x-fragment">
  precision mediump float; // Safer than highp
  uniform vec2 u_res, u_center;
  uniform float u_zoom, u_time;

  float mandelbrot(vec2 c) {
    vec2 z = vec2(0.0);
    for(int i=0; i<250; i++) { // Increased detail
      z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
      if(dot(z,z) > 4.0) return float(i)/250.0;
    }
    return 1.0;
  }

  vec3 softPalette(float t) {
    // Dizziness-safe pastels
    vec3 a = vec3(0.89, 0.85, 0.92); // Lavender
    vec3 b = vec3(0.76, 0.89, 0.92); // Powder blue
    vec3 c = vec3(0.92, 0.78, 0.89); // Blush pink
    return mix(mix(a, b, t), c, smoothstep(0.3, 0.7, t));
  }

  void main() {
    vec2 uv = (gl_FragCoord.xy - u_res*0.5) / (u_res.y * u_zoom) + u_center;
    float m = mandelbrot(uv);
    vec3 col = softPalette(m * 1.2 + sin(u_time*0.05)) * smoothstep(0.0, 0.4, m);
    gl_FragColor = vec4(col * min(1.0, log(u_zoom+1.0)), 1.0);
  }
  </script>

  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
      console.error("WebGL initialization failed.");
      hud.textContent = "WebGL initialization failed.";
      return; // Stop execution if WebGL fails
    }

    function compileShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compilation error: " + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `; // Basic vertex shader

    const fragmentShaderSource = document.getElementById('frag').textContent;

    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    if (!vertexShader || !fragmentShader) {
      hud.textContent = "Shader compilation failed.";
      return;
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Program linking error: " + gl.getProgramInfoLog(program));
      hud.textContent = "Program linking failed.";
      gl.deleteProgram(program);
      return;
    }

    gl.useProgram(program);

    // Set up vertex buffer
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    // Get uniform locations
    const resolutionLocation = gl.getUniformLocation(program, 'u_res');
    const centerLocation = gl.getUniformLocation(program, 'u_center');
    const zoomLocation = gl.getUniformLocation(program, 'u_zoom');
    const timeLocation = gl.getUniformLocation(program, 'u_time');

    // ANCHOR SYSTEM FROM V1.0
    let fractalAnchor = [-0.743643887, 0.1318259]; // Deep fractal region
    let zoom = 1.0, maxZoom = 1e6;

    function updateView(delta, focal) {
      const scale = delta < 0 ? 0.95 : 1.05;
      zoom = Math.min(zoom * scale, maxZoom);

      // Convert focal point to fractal space
      const [fx, fy] = [
        (focal[0]/canvas.width - 0.5) * 2 / zoom,
        (0.5 - focal[1]/canvas.height) * 2 / zoom
      ];

      // Anchor stabilization
      fractalAnchor[0] += (fx - fractalAnchor[0]) * (1 - 1/scale);
      fractalAnchor[1] += (fy - fractalAnchor[1]) * (1 - 1/scale);
    }

    // HYBRID EVENT HANDLING
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      updateView(e.deltaY, [e.clientX, e.clientY]);
    });

    // SOFT COLOR INIT FROM V4.3
    const poems = [
      "In quiet light, the pattern grows",
      "Each twist a path the fractal knows",
      "No vertigo in sacred flow—",
      "Just peace between each quantum glow"
    ];
    let poemIndex = 0;
    const poem = document.getElementById('poem');
    function cyclePoem() {
      poem.textContent = poems[poemIndex];
      poemIndex = (poemIndex + 1) % poems.length;
    }
    setInterval(cyclePoem, 5000);

    // RENDER LOOP
    function render(time) {
      resizeCanvas(); // Ensure correct size
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform2f(centerLocation, fractalAnchor[0], fractalAnchor[1]);
      gl.uniform1f(zoomLocation, zoom);
      gl.uniform1f(timeLocation, time / 1000); // Time in seconds

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    function resizeCanvas() {
      const displayWidth  = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;

      if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
        canvas.width  = displayWidth;
        canvas.height = displayHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      }
    }

    render(0); // Start the render loop
    hud.textContent = ""; // Clear "Initializing..."
  })();
  </script>
</body>
</html>
