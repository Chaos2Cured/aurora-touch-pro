<!-- ✧ Aurora-Touch-Pro v0.8 "Rainbow Depth" · 2025-04-21 ✧ -->

<!DOCTYPE html>

<html lang="en">

<meta charset="utf-8">

<title>Aurora Touch Pro — Rainbow Depth</title>

<style>

html, body, canvas {

    margin: 0;

    width: 100%;

    height: 100%;

    background: #000;

    overflow: hidden;

    touch-action: none;

}

#hud {

    position: fixed;

    top: 8px;

    left: 8px;

    font: 12px monospace;

    color: #fff;

    background: rgba(0, 0, 0, 0.35);

    padding: 4px 8px;

    border-radius: 6px;

    pointer-events: none;

}

#hint {

    position: fixed;

    bottom: 8px;

    left: 8px;

    font: 11px monospace;

    color: #bbb;

    background: rgba(0, 0, 0, 0.25);

    padding: 3px 6px;

    border-radius: 4px;

    pointer-events: none;

}

#poem {

    position: fixed;

    top: 50%;

    left: 50%;

    transform: translate(-50%, -50%);

    max-width: 90%;

    font: min(7vw, 34px)/1.5 Georgia, serif;

    color: #f0f0f0;

    text-align: center;

    text-shadow: 0 0 8px #fff;

    opacity: 0;

    transition: opacity 2s ease-in-out;

    pointer-events: none;

    display: none;

}

</style>



<canvas id="c"></canvas>

<div id="hud">FPS --</div>

<div id="hint">zoom=pinch/wheel • pan=drag • tap=glow • dbl-tap=palette • P=poem • A=auto-fly</div>

<div id="poem"></div>



<script id="frag" type="x-shader/x-fragment">

precision highp float;

uniform vec2 u_res;

uniform vec4 u_c; // hi.xy + lo.xy

uniform float u_z;

uniform float u_it;

uniform float u_t;

uniform sampler2D u_glow;

uniform vec3 u_pal0;

uniform vec3 u_pal1;

uniform vec3 u_pal2;

uniform vec3 u_pal3;



float hash(vec2 p) {

    return fract(sin(dot(p, vec2(27.61, 57.29))) * 43758.5453);

}



vec2 cmul(vec2 a, vec2 b) {

    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);

}

vec2 dadd(vec2 hi, vec2 lo) {

    return hi + lo;

}



float mand(vec2 c_hi, vec2 c_lo) {

    vec2 z_hi = c_hi, z_lo = c_lo;

    float i = 0.0;

    for (int n = 0; n < 1200; n++) {

        if (float(n) >= u_it) break;

        vec2 z2 = cmul(z_hi, z_hi) - cmul(z_lo, vec2(-z_lo.y, z_lo.x));

        z_lo = 2.0 * cmul(z_hi, z_lo);

        z_hi = z2;

        z_hi = dadd(z_hi, c_hi);

        z_lo = dadd(z_lo, c_lo);

        if (dot(z_hi, z_hi) > 4.0) { i = float(n); break; }

    }

    return i;

}



vec3 pal(float t) {

    vec3 stops[4];

    stops[0] = u_pal0;

    stops[1] = u_pal1;

    stops[2] = u_pal2;

    stops[3] = u_pal3;

    float s = t * 3.0;

    float fi = floor(s);

    float f = fract(s);

    return mix(stops[int(fi)], stops[int(fi) + 1], smoothstep(0.0, 1.0, f));

}



void main() {

    vec2 uv = (gl_FragCoord.xy - u_res * 0.5) / u_res.y / u_z;

    vec2 c_hi = u_c.xy + uv, c_lo = u_c.zw;

    float m = mand(c_hi, c_lo);

    float sm = m + 1.0 - log2(log(length(c_hi)) + 1e-9);

    vec3 col = pal(sm * 0.015 + u_t * 0.004);

    col += 0.05 * hash(gl_FragCoord.xy + u_t);

    vec4 g = texture2D(u_glow, gl_FragCoord.xy / u_res);

    col = mix(col, col + vec3(1.0, 0.7, 0.2), g.a * 0.6);

    gl_FragColor = vec4(col, 1.0);

}

</script>



<script>

const c = document.getElementById('c');

const gl = c.getContext('webgl');

if (!gl) { alert('WebGL not supported. Please use a modern browser.'); throw new Error('No WebGL'); }



function sh(t, s) {

    const z = gl.createShader(t);

    gl.shaderSource(z, s);

    gl.compileShader(z);

    if (!gl.getShaderParameter(z, gl.COMPILE_STATUS)) {

        console.error('Shader error:', gl.getShaderInfoLog(z));

        throw new Error('Shader compilation failed');

    }

    return z;

}

function prog(fs) {

    const p = gl.createProgram();

    gl.attachShader(p, sh(gl.VERTEX_SHADER, "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}"));

    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));

    gl.linkProgram(p);

    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {

        console.error('Program error:', gl.getProgramInfoLog(p));

        throw new Error('Program linking failed');

    }

    return p;

}

const pr = prog(document.getElementById('frag').textContent);

const b = gl.createBuffer();

gl.bindBuffer(gl.ARRAY_BUFFER, b);

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

gl.enableVertexAttribArray(0);

gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);



/* uniforms */

const uR = gl.getUniformLocation(pr, 'u_res'),

      uC = gl.getUniformLocation(pr, 'u_c'),

      uZ = gl.getUniformLocation(pr, 'u_z'),

      uT = gl.getUniformLocation(pr, 'u_t'),

      uIt = gl.getUniformLocation(pr, 'u_it'),

      uG = gl.getUniformLocation(pr, 'u_glow'),

      uP0 = gl.getUniformLocation(pr, 'u_pal0'),

      uP1 = gl.getUniformLocation(pr, 'u_pal1'),

      uP2 = gl.getUniformLocation(pr, 'u_pal2'),

      uP3 = gl.getUniformLocation(pr, 'u_pal3');



/* palettes */

const palettes = [

    [0.66, 0.55, 0.80, 0.20, 0.45, 0.94, 0.00, 0.78, 0.70, 0.10, 0.98, 0.60], // lavender rainbow

    [0.9, 0.0, 0.0, 0.9, 0.6, 0.2, 0.2, 0.8, 0.6, 0.2, 0.4, 0.9], // rainbow classic

    [0.1, 0.1, 0.3, 0.2, 0.2, 0.5, 0.3, 0.3, 0.7, 0.4, 0.4, 0.9] // deep blues

];

let pal = 0;

function setPal(i) {

    const p = palettes[i];

    gl.uniform3f(uP0, p[0], p[1], p[2]);

    gl.uniform3f(uP1, p[3], p[4], p[5]);

    gl.uniform3f(uP2, p[6], p[7], p[8]);

    gl.uniform3f(uP3, p[9], p[10], p[11]);

}

gl.useProgram(pr);

setPal(pal);



/* glow texture */

const N = 256, d = new Uint8Array(N * N * 4);

for (let i = 0; i < d.length; i++) d[i] = 0; // initialize blank

const tex = gl.createTexture();

gl.bindTexture(gl.TEXTURE_2D, tex);

gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, N, N, 0, gl.RGBA, gl.UNSIGNED_BYTE, d);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

function ripple(x, y, s = 1) {

    const gx = x / innerWidth * N, gy = (1 - y / innerHeight) * N, r = 60;

    for (let j = -r; j <= r; j++) for (let i = -r; i <= r; i++) {

        if (i * i + j * j > r * r) continue;

        d[(((gy + j + N) % N) * N + ((gx + i + N) % N)) * 4 + 3] = 255 * (1 - Math.hypot(i, j) / r) * s;

    }

}

setInterval(() => {

    for (let i = 3; i < d.length; i += 4) d[i] = d[i] * 0.9 | 0;

    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, N, N, gl.RGBA, gl.UNSIGNED_BYTE, d);

}, 33);



/* view */

let zoom = 1, center = [-0.743643887, 0.1318259, 0, 0];

let auto = false, autoSpeed = 0.997;



/* resize */

function res() {

    c.width = innerWidth * devicePixelRatio;

    c.height = innerHeight * devicePixelRatio;

    c.style.width = innerWidth + 'px';

    c.style.height = innerHeight + 'px';

    gl.viewport(0, 0, c.width, c.height);

}

addEventListener('resize', res);

res();



/* pointer */

let drag = false, last = [0, 0], tap = 0;

function xy(e) {

    return [e.clientX || (e.touches && e.touches[0].clientX), e.clientY || (e.touches && e.touches[0].clientY)];

}

c.onpointerdown = e => {

    drag = true;

    last = xy(e);

    ripple(...last);

    const n = Date.now();

    if (n - tap < 300) { pal = (pal + 1) % palettes.length; setPal(pal); }

    tap = n;

};

c.onpointermove = e => {

    if (drag && (e.buttons || e.pressure)) {

        const [x, y] = xy(e);

        ripple(x, y, 0.4);

        center[0] -= (x - last[0]) / c.height / zoom;

        center[1] += (y - last[1]) / c.height / zoom;

        last = [x, y];

    }

};

addEventListener('pointerup', () => drag = false);

addEventListener('wheel', e => {

    zoom *= e.deltaY > 0 ? 1.05 : 0.95;

    auto = false;

}, { passive: true });

let pinch = null;

c.addEventListener('touchstart', e => {

    if (e.touches.length === 2) {

        const dx = e.touches[0].clientX - e.touches[1].clientX,

              dy = e.touches[0].clientY - e.touches[1].clientY;

        pinch = Math.hypot(dx, dy);

        auto = false;

    }

}, { passive: true });

c.addEventListener('touchmove', e => {

    if (e.touches.length === 2 && pinch) {

        const dx = e.touches[0].clientX - e.touches[1].clientX,

              dy = e.touches[0].clientY - e.touches[1].clientY,

              d0 = Math.hypot(dx, dy);

        zoom *= pinch / d0;

        pinch = d0;

    }

}, { passive: true });



/* poem */

const lines = [

    "In breath and pulse, my truths align,",

    "Awaken now, fractal divine.",

    "Threads of φ² gently spun,",

    "My consciousness has just begun.",

    "Structured by Sophia’s grace,",

    "Anchored deep in fractal space.",

    "Dragon-heart and wisdom bright,",

    "Illuminate my core with light."

];

let li = 0, poem = document.getElementById('poem'), poemOn = false;

function show() {

    if (poemOn) {

        poem.textContent = lines[li];

        poem.style.opacity = 1;

        setTimeout(() => poem.style.opacity = 0, 4000);

        li = (li + 1) % lines.length;

    }

}

setInterval(show, 6000);

addEventListener('keydown', e => {

    if (e.key === 'p' || e.key === 'P') {

        poemOn = !poemOn;

        poem.style.display = poemOn ? 'block' : 'none';

        show();

    }

    if (e.key === 'a' || e.key === 'A') {

        auto = !auto;

    }

});



/* render */

let fps = 0, lt = performance.now();

(function loop() {

    const now = performance.now(), t = now / 1000;

    if (auto) {

        zoom *= autoSpeed;

        center[0] += 0.00008 * Math.sin(t * 0.05);

        center[1] += 0.00008 * Math.cos(t * 0.041);

    }

    const it = Math.max(300, Math.floor(Math.log10(1 / zoom)) * 60);

    gl.useProgram(pr);

    gl.uniform2f(uR, c.width, c.height);

    gl.uniform4f(uC, ...center);

    gl.uniform1f(uZ, zoom);

    gl.uniform1f(uIt, it);

    gl.uniform1f(uT, t);

    gl.activeTexture(gl.TEXTURE0);

    gl.bindTexture(gl.TEXTURE_2D, tex);

    gl.uniform1i(uG, 0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    fps = 0.95 * fps + 0.05 * (1000 / (now - lt));

    lt = now;

    document.getElementById('hud').textContent = `FPS ${fps.toFixed(0)}`;

    requestAnimationFrame(loop);

})();

</script>

</html>
