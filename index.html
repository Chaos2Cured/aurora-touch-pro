<!-- Aurora‑Touch‑Pro v1.0 • minimal working skeleton -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Aurora Touch Pro — Minimal Fractal</title>
<style>
 html,body,canvas{margin:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none}
 #hud{position:fixed;top:8px;left:8px;font:12px monospace;color:#0f0;background:rgba(0,0,0,.55);padding:4px 8px;border-radius:4px;pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas><div id="hud">init…</div>

<script id="frag" type="x-shader/x-fragment">
precision mediump float;
uniform vec2  u_res, u_center;
uniform float u_zoom, u_iter, u_time;

/* simple 4‑stop pastel gradient */
vec3 pal(float t){
    t = clamp(t,0.0,1.0);
    vec3 a = vec3(0.80,0.70,0.95); // lavender
    vec3 b = vec3(0.55,0.80,0.95); // soft blue
    vec3 c = vec3(0.45,0.90,0.80); // turquoise
    vec3 d = vec3(0.80,0.95,0.75); // mint
    if(t<0.33) return mix(a,b,t*3.0);
    else if(t<0.66) return mix(b,c,(t-0.33)*3.0);
    else return mix(c,d,(t-0.66)*3.0);
}

float mand(vec2 c){
    vec2 z = vec2(0.0); float i;
    for(i=0.0;i<300.0;i++){
        if(i>=u_iter) break;
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if(dot(z,z)>4.0) break;
    }
    return i;
}

void main(){
    vec2 uv = (gl_FragCoord.xy - u_res*0.5) / u_res.y / u_zoom + u_center;
    float m = mand(uv);
    float t = m / u_iter;
    vec3 col = (m>=u_iter)? vec3(0.0) : pal(t);
    gl_FragColor = vec4(col,1.0);
}
</script>

<script>
const gl = c.getContext('webgl');
function compile(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s;}
const pr = gl.createProgram();
const vs = 'attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}';
gl.attachShader(pr,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(pr,compile(gl.FRAGMENT_SHADER,frag.textContent));
gl.linkProgram(pr);if(!gl.getProgramParameter(pr,gl.LINK_STATUS))throw gl.getProgramInfoLog(pr);
gl.useProgram(pr);
/* quad */
const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
/* uniforms */
const uR=gl.getUniformLocation(pr,'u_res'),uC=gl.getUniformLocation(pr,'u_center'),uZ=gl.getUniformLocation(pr,'u_zoom'),uI=gl.getUniformLocation(pr,'u_iter'),uT=gl.getUniformLocation(pr,'u_time');

/* view */
let zoom=1.0,center={x:-0.743643887,y:0.1318259};
function resize(){const dpr=window.devicePixelRatio||1;c.width=innerWidth*dpr;c.height=innerHeight*dpr;gl.viewport(0,0,c.width,c.height);gl.uniform2f(uR,c.width,c.height);}resize();addEventListener('resize',resize);
/* pointer controls */
let drag=false,last=[0,0];
function xy(e){return[e.clientX||e.touches[0].clientX,e.clientY||e.touches[0].clientY];}
c.onpointerdown=e=>{drag=true;last=xy(e);};
c.onpointermove=e=>{if(!drag)return;const[x,y]=xy(e);center.x-=(x-last[0])/c.height/zoom;center.y+=(y-last[1])/c.height/zoom;last=[x,y];};
addEventListener('pointerup',()=>drag=false);
addEventListener('wheel',e=>{zoom*=e.deltaY>0?1.1:0.9;},{passive:true});

/* render */
const hud=document.getElementById('hud');let fps=0,last=performance.now();
(function loop(){const now=performance.now();const t=now/1000;gl.uniform2f(uC,center.x,center.y);gl.uniform1f(uZ,zoom);gl.uniform1f(uI,300.0);gl.uniform1f(uT,t);gl.drawArrays(gl.TRIANGLE_STRIP,0,4);fps=0.9*fps+0.1*(1000/(now-last));last=now;hud.textContent=`FPS ${fps.toFixed(0)}  |  zoom ${zoom.toFixed(2)}`;requestAnimationFrame(loop);})();
</script>
</body>
</html>
